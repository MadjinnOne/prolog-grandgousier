## 0. Clarifier les objectifs fonctionnels (ce que le bot doit savoir faire)

À terme, votre bot doit couvrir au minimum les familles de questions suivantes (celles explicitement conseillées comme base, puis l’extension)  :

1. Conseiller des vins d’une appellation/région
   Ex: « Quels vins de Bourgogne me conseillez-vous ? »

2. Décrire un vin: bouche, nez, description globale
   Ex: « Que donne le Nuits-Saint-Georges en bouche ? », « Quel nez présente le Chambolle-Musigny ? », « Pourriez-vous m’en dire plus sur La Fleur de Pomys ? »

3. Expliquer une appellation
   Ex: « Que recouvre l’appellation Haut-Médoc ? »

4. Gérer une contrainte de prix
   Ex: « Auriez-vous des vins entre 20 et 35 EUR ? »

5. Conseiller un vin selon un plat/repas
   Ex: « Pour Noël, canard. Quel vin me conseillez-vous ? »

6. Gérer la continuité du dialogue
   Ex: « Auriez-vous d’autres vins de Bourgogne ? » (référence à la demande précédente)

La roadmap ci-dessous construit ces capacités dans un ordre “du plus simple au plus complexe”, comme recommandé. 

## 1) Stabiliser le pipeline d’entrée/sortie (aucune “intelligence” encore)

Objectif: garantir qu’une phrase utilisateur devient une liste de mots, puis qu’une réponse (liste de listes) s’affiche correctement.

Livrables

* `grandgousier/0` fonctionne en boucle (déjà dans le squelette).
* Un `produire_reponse/2` minimal: répond par défaut “je ne sais pas …” sauf si l’utilisateur tape `fin`.

Tests rapides

* Entrée: `fin` → sortie: message de clôture.
* Entrée: n’importe quoi → sortie: message par défaut.

## 2) Mettre en place la “stratégie mots-clés pondérés” (sans règles métiers complexes)

Objectif: extraire les mots-clés présents dans `L_mots`, les trier par importance, puis tenter des règles dans cet ordre. 

Livrables

* Faits `mclef(MotClef, Poids).`
* Prédicats:

  * `mots_cles(L_mots, L_kws)` (filtrage)
  * `trier_kws(L_kws, L_kws_tries)` (ordre décroissant de poids)
* Stratégie d’exécution:

  * pour chaque `KW` dans `L_kws_tries`, tester les `regle_rep(KW, ...)`

Tests

* Vérifier que, pour une phrase contenant plusieurs mots-clés, le plus “important” pilote la réponse.

## 3) Implémenter le matching de patterns, de manière contrôlée

Objectif: décider quand une règle “matche” la question.

Recommandation pratique

* Commencer avec un matching simple de sous-liste (comme `sublist/2`).
* Prévoir une variante “tolérante” (distance, fenêtres) uniquement après que le fonctionnel de base tourne.

Livrables

* `match_pattern(Pattern, L_mots)` (avec sous-liste)
* Convention de patterns: listes de mots normalisés (minuscules, sans ponctuation, comme indiqué). 

Tests

* Une règle avec pattern `[quels, vins, de, bourgogne]` doit matcher « Quels vins de Bourgogne me conseillez-vous ».

## 4) Construire la base de connaissances minimale “vins”

Objectif: pouvoir répondre à “quels vins de X”, “prix”, “bouche/nez/description”. L’énoncé suggère explicitement des prédicats de ce type. 

Livrables (minimum)

* `nom(Id, AppellationTexte).`
* `prix(Id, Prix).`
* `bouche(Id, TexteListeDeListes).`
* `nez(Id, TexteListeDeListes).`
* `description(Id, TexteListeDeListes).`
* (optionnel mais utile) `appellation(Id, A).`, `couleur(Id, C).`, `accord(Id, PlatOuStyle).`

Tests

* Requête interne: lister les vins d’une appellation et leurs prix.
* Vérifier que vos textes sont bien au format attendu par `ecrire_reponse/1` (liste de listes).

## 5) Première vraie compétence: “Quels vins de <appellation>…”

Objectif: produire une réponse listant N vins filtrés par appellation, avec un mini commentaire et le prix.

Livrables

* Une règle `regle_rep(conseil_vins, ..., Pattern, Rep)` ou similaire, déclenchée par des mots-clés du type `vin`, `conseillezvous`, et par la présence d’une appellation.
* Un prédicat auxiliaire:

  * `vins_par_appellation(App, ListeIdsTriesOuNon)`
  * `formatter_liste_vins(ListeIds, LignesReponse)` (inclure prix)

Tests

* « Quels vins de Bourgogne… » doit afficher une liste de vins de Bourgogne.

## 6) “Bouche”, “Nez”, “En dire plus sur <vin>”

Objectif: exploiter `bouche/2`, `nez/2`, `description/2`.

Livrables

* Normalisation des noms de vins (reconnaissance d’un vin dans la question). Deux approches:

  1. Simple: matcher directement des tokens du nom.
  2. Robuste: pré-traitement qui remplace un groupe de mots par un identifiant de vin (ex: `v04`), comme dans votre code d’exemple.
* Règles:

  * pattern contenant `bouche` + `VinId` → `bouche(VinId, Texte)`
  * pattern contenant `nez` + `VinId` → `nez(VinId, Texte)`
  * pattern `decris` ou équivalent + `VinId` → `description(VinId, Texte)`

Tests

* « Que donne <vin> en bouche ? »
* « Quel nez présente <vin> ? »
* « Pourriez-vous m’en dire plus sur <vin> ? »

## 7) Explication d’appellation: “Que recouvre l’appellation <X>”

Objectif: retourner une définition (texte) pour une appellation donnée.

Livrables

* Base: `definition_appellation(App, TexteListeDeListes).`
* Règle: pattern `recouvre` ou `couvre` + `appellation` + `App`

Tests

* « Que recouvre l’appellation Haut-Médoc ? »

## 8) Filtre de prix: “entre A et B”, “moins de”, “plus de”

Objectif: filtrer les vins par prix, indépendamment ou en complément (selon votre design) de la région.

Livrables

* Parse simple de nombres dans `L_mots` (attention: `read_atomics/1` renvoie des atomiques, souvent nombres déjà reconnus).
* Prédicat:

  * `vins_dans_intervalle(A, B, ListeIds)`
  * puis formattage en lignes

Tests

* « Auriez-vous des vins entre 20 et 35 EUR ? »
* « Des vins à moins de 15 EUR ?  », « Des vins à plus de 40 EUR ? »

## 9) Continuité: “d’autres vins de Bourgogne”

Objectif: gérer le contexte, sinon cette phrase est ambiguë.

Livrables

* Mémoire courte de dialogue, par exemple via prédicats dynamiques:

  * `:- dynamic dernier_filtre/2.` (ex: `dernier_filtre(appellation, bourgogne)`)
  * ou `dernier_sujet(appellation(bourgogne)).`
* Règle “des autres”: si le pattern contient `des_autres` (ou “autres”), alors:

  * récupérer le dernier filtre (appellation)
  * proposer la suite des vins non encore proposés (tenir une liste “déjà proposés” en mémoire)

Tests

* 1. demander Bourgogne → liste 1
* 2. dm→ liste 2 différente

## 10) Accord mets-vins: “je cuisine du canard, quel vin…”

Objectif: passer d’un plat à un style de vin, puis à des appellations, comme l’exemple du sujet.

Livrables

* Une base de règles “plat → profil” puis “profil → appellations”.

  * ex: `profil_plat(canard, rouge_puissant_epice_fume).`
  * `appellations_profil(rouge_puissant_epice_fume, [haut_medoc, graves, ...]).`
* Règle de réponse: détecter `cuisiner` + `Plat` puis proposer les appellations.

Tests

* « Pour Noël, canard… » → recommandations par régions/appellations.

## 11) Durcissement et qualité (après que tout marche)

Objectif: améliorer robustesse sans casser le pipeline.

Pistes typiques

* Normalisation linguistique: synonymes, regroupement d’expressions (“auriez-vous”, “recommandez-vous”, etc.).
* Tolérance aux fautes: correction approximative sur mots importants seulement.
* Couverture: ajouter vos propres dialogues inventés (attendu, “bienvenus”). 
* Traçabilité: un mode debug qui affiche `L_mots` normalisé, les KW détectés et la règle choisie.
