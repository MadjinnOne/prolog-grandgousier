## 1. Stack technique proposÃ©e

### 1.1. Langage & runtime

* **Langage** : Prolog (SWI-Prolog, comme prÃ©vu par le squelette).
* **InterprÃ©teur** :

  * Installer **SWI-Prolog** (swipl).
  * Commande de base pour lancer le bot :

    ```bash
    swipl -s grandgousier.pl
    ```
  * Ã‰ventuellement un petit script `run.sh` ou `run.bat` pour faciliter les tests.

### 1.2. IDE / Ã©diteur (JetBrains)

Tu as une licence JetBrains, donc :

* **IDE principal** : **IntelliJ IDEA** (Community ou Ultimate).
* **Pour Prolog** :

  * Utiliser un **plugin Prolog** (pour la coloration, indentation, etc.) si vous en trouvez un compatible.
  * Sinon, IntelliJ reste trÃ¨s bien pour lâ€™Ã©dition (git intÃ©grÃ©, search, etc.), et vous lancez SWI-Prolog dans un terminal Ã  cÃ´tÃ©.
* Organisation suggÃ©rÃ©e des fichiers :

  * `src/grandgousier.pl` (code final)
  * `src/grandgousier-elm.pl` (rÃ©fÃ©rence / brouillon)
  * `src/eliza.pl` (si besoin pour sâ€™inspirer)
  * `data/grafe-lecocq.tex` (texte des vins)
  * `doc/` pour le rapport

### 1.3. Gestion de versions / collaboration

* **Git + GitHub** :

  * Un seul repo, par ex. `unamur-grandgousier-2025`.
  * Branch principale : `main`.
  * Branches de travail : `feature/â€¦`, par ex. `feature/moteur-regles`, `feature/base-vins`, etc.

Fichiers utiles :

* `.gitignore` :

  * Ignorer : fichiers temporaires, `.swp`, `.DS_Store`, Ã©ventuellement build/log si vous en gÃ©nÃ©rez.
* `README.md` :

  * Comment lancer le programme.
  * Version de SWI-Prolog testÃ©e.
  * Auteurs.

### 1.4. Documentation / rapport

* Vu la prÃ©sence de `grafe-lecocq.tex`, **LaTeX** est naturel pour le rapport :

  * `doc/rapport.tex`
  * Compilation via latexmk ou Overleaf (Ã  vous de voir).
* Si vous prÃ©fÃ©rez simple : **Markdown** + export PDF.
  Mais je parierais que le prof aime bien LaTeX ğŸ˜„

---

## 2. Organisation Ã  deux sur GitHub

### 2.1. RÃ´les (mais vous tournez rÃ©guliÃ¨rement)

* **Personne A â€“ â€œmoteur & rÃ¨glesâ€**

  * Comprendre en dÃ©tail `produire_reponse/2`, `mclef/2`, `regle_rep/4`.
  * ImplÃ©menter les rÃ¨gles de dialogue (patterns, conditions).
* **Personne B â€“ â€œbase de connaissances & rapportâ€**

  * Extraire les infos de `grafe-lecocq.tex`.
  * Construire les faits Prolog : `nom/2`, `prix/2`, `nez/2`, `bouche/2`, `description/2`, `appellation/2`, etc.
  * Documenter les choix dans le rapport.

Mais **chacun relit le code de lâ€™autre** via des pull requests.

### 2.2. Workflow Git simple

1. Un de vous crÃ©e le repo sur GitHub et pousse le squelette `grandgousier.pl`.
2. Pour chaque Ã©volution :

   * `git checkout -b feature/mclef`
   * coder / tester
   * `git commit` + `git push`
   * ouvrir une Pull Request, lâ€™autre relit.
3. Merge dans `main` seulement quand Ã§a tourne (tests manuels de quelques dialogues).

---

## 3. Roadmap du projet

Je te fais une roadmap **progressive**, en suivant aussi le conseil de lâ€™Ã©noncÃ© (â€œdu plus simple au plus complexeâ€).

### Ã‰tape 0 â€” Mise en place (trÃ¨s rapide)

* CrÃ©er le repo GitHub et y mettre :

  * `grandgousier.pl` (squelette fourni)
  * `projet.pdf`, `grafe-lecocq.tex` dans `data/` ou `doc/`
* VÃ©rifier que :

  * `swipl -s grandgousier.pl` lance bien le bot.
  * Une question triviale donne la rÃ©ponse par dÃ©faut (â€œje ne sais pasâ€).

---

### Ã‰tape 1 â€” ComprÃ©hension & mini-tests

* Lire attentivement :

  * Le fonctionnement de `read_atomics/1` et `ecrire_reponse/1`.
  * Le code fourni dans le squelette (notamment les exemples de `bouche/2`, `nez/2`, `mclef/2`, `regle_rep/4`).
* Faire de **petits tests** :

  * Tester une rÃ¨gle dÃ©jÃ  codÃ©e (par ex. la rÃ¨gle sur `bouche` ou les prix min/max).
  * Comprendre comment `match_pattern/2` et `nom_vins_uniforme/2` fonctionnent.

Objectif : Ãªtre Ã  lâ€™aise avec le fait que **tout se fait via des listes de mots en minuscules**.

---

### Ã‰tape 2 â€” PremiÃ¨re version â€œminimaleâ€ des dialogues simples

Cibler dâ€™abord les **4 questions â€œsimplesâ€** de lâ€™Ã©noncÃ© :

1. â€œQuels vins de Bourgogne me conseillez-vous ?â€
2. â€œQue donne le Nuits-Saint-Georges en bouche ?â€
3. â€œQuel nez prÃ©sente le Chambolle-Musigny ?â€
4. â€œQue recouvre lâ€™appellation Haut-MÃ©doc ?â€

Sous-tÃ¢ches :

* DÃ©finir quelques vins dans la base Prolog :

  * `nom(Id, 'Appellation complÃ¨te').`
  * `prix(Id, Prix).`
  * `nez(Id, Texte).`
  * `bouche(Id, Texte).`
  * `description(Id, Texte).`
  * `appellation(Id, RegionOuTexte).`
* CrÃ©er des premiÃ¨res rÃ¨gles `mclef/2` (par ex. `mclef(bourgogne, 10).`, `mclef(appellation, 10).`, etc.).
* Pour chaque type de question, une rÃ¨gle `regle_rep/4` avec un **pattern rÃ©aliste** (liste de mots minuscules, sans ponctuation) et une rÃ©ponse en liste de listes.

Objectif : **reproduire ces 4 dialogues** (Ã  quelques dÃ©tails prÃ¨s) en restant propre.

---

### Ã‰tape 3 â€” Gestion des â€œautres vins de Bourgogneâ€ & prix

On passe aux dialogues plus avancÃ©s :

1. â€œAuriez-vous dâ€™autres vins de Bourgogne ?â€
2. â€œAuriez-vous des vins entre 20 et 35 EUR ?â€

Sous-tÃ¢ches :

* Concevoir une stratÃ©gie pour â€œautres vins de Bourgogneâ€ :

  * Garder en mÃ©moire les vins dÃ©jÃ  proposÃ©s ? (via un prÃ©dicat dynamique ou un choix simple : sÃ©parer premiÃ¨re recommandation et â€œautresâ€ via des listes diffÃ©rentes).
* Utiliser / adapter les prÃ©dicats dÃ©jÃ  prÃ©sents pour les **prix min/max** (il y a dÃ©jÃ  des Ã©lÃ©ments dans le squelette) :

  * `prix_vin_min_max/4`, `lvins_prix_min_max/3`, `rep_lvins_min_max/2`, etc.
* Ajouter les `regle_rep/4` correspondantes :

  * Pattern pour la question â€œauriezvous des vins entre X et Y eurâ€ (comme dans le squelette).
  * Un ou deux patterns pour â€œautres vins de bourgogneâ€.

Objectif : les deux questions sur les **autres vins** et les **tranches de prix** doivent fonctionner.

---

### Ã‰tape 4 â€” Description dÃ©taillÃ©e dâ€™un vin & liens avec les textes

Dialogue :
â€œPourriez-vous mâ€™en dire plus sur La Fleur de Pomys ?â€

Sous-tÃ¢ches :

* RÃ©cupÃ©rer dans `grafe-lecocq.tex` la **description** textuelle de ce vin, et la transformer en :

  * `description(id_fleur_de_pomys_2012, [[...],[...],...]).`
* Ajouter une **rÃ¨gle** `regle_rep(description, â€¦)` ou similaire :

  * Pattern incluant le nom du vin normalisÃ© (via `nom_vins_uniforme/2` si nÃ©cessaire).
  * La rÃ©ponse se base sur `description/2`.

Objectif : question sur â€œen dire plusâ€ â†’ affichage de la description structurÃ©e en lignes.

---

### Ã‰tape 5 â€” Recommandation par plat (canard)

Dialogue :
â€œPour NoÃ«l, jâ€™envisage de cuisiner du canard. Quel vin me conseillez-vous ?â€

Sous-tÃ¢ches :

* CrÃ©er un petit **module de rÃ¨gles dâ€™association platsâ€“profils de vin** :

  * par ex. `profil(canard, rouge_puissant_epice_fume).`
  * et des associations de profils Ã  rÃ©gions / appellations.
* Concevoir `regle_rep(plat, â€¦)` qui :

  * dÃ©tecte `noel` / `canard` / `viande` dans la question.
  * renvoie un texte du type de celui de lâ€™Ã©noncÃ©.

Objectif : donner au moins les familles de vins proposÃ©es (Haut-MÃ©doc, Graves, etc.).

---

### Ã‰tape 6 â€” Robustesse, variantes & petits plus

* GÃ©rer quelques **variantes linguistiques** :

  * â€œquels vins de bourgogne pouvez vous me conseillerâ€
  * â€œje cherche des vins de bourgogneâ€
* Ajouter des **rÃ¨gles par dÃ©faut** un peu plus fines que le simple â€œje ne sais pasâ€.
* Enrichir la base de vins si vous avez encore du temps (toujours Ã  partir des textes fournis, pas dâ€™invention).

---

### Ã‰tape 7 â€” Rapport

Structure possible :

1. **Introduction**

   * Description du problÃ¨me (bot conseiller en vins).
   * Contexte du projet.
2. **Stack & outils**

   * SWI-Prolog, organisation du code, organisation GitHub.
3. **Architecture du programme**

   * RÃ´le de `read_atomics/1`, `produire_reponse/2`, `ecrire_reponse/1`, boucle `grandgousier/0`.
4. **ReprÃ©sentation des connaissances**

   * Faits `nom/2`, `prix/2`, `nez/2`, `bouche/2`, `description/2`, `appellation/2`, etc.
5. **Moteur de rÃ¨gles**

   * `mclef/2`, `regle_rep/4`, patterns, prÃ©dicats auxiliaires (`match_pattern`, etc.).
6. **Exemples de dialogues**

   * Capture dâ€™Ã©cran ou transcript de dialogues correspondant Ã  ceux de lâ€™Ã©noncÃ© + autres imaginÃ©s.
7. **Limites & amÃ©liorations possibles**

   * Ce que vous nâ€™avez pas eu le temps de faire, pistes dâ€™extension.

---

Si tu veux, Ã  la prochaine Ã©tape on peut :

* dÃ©tailler lâ€™architecture du repo (fichiers prÃ©cis), **ou**
* commencer directement par dÃ©finir les premiers `mclef/2` et `regle_rep/4` nÃ©cessaires pour â€œQuels vins de Bourgogne me conseillez-vous ?â€.
